\BLOCK{- if show_question -}
\BLOCK{- if pre_description -}
\VAR{pre_description}
\BLOCK{- endif -} \#{ pre_description }

\BLOCK{ if lp }
$$\begin{alignat*}{20}
\VAR{lp.get_goal_str()}\\
\text{s.t.}\quad
\BLOCK{ for c in lp.constraints_str_list }
\VAR{c}
\BLOCK{ endfor }
\VAR{lp.sign_str}
\end{alignat*}$$
\BLOCK{ endif }

\BLOCK{ if after_description -}
\VAR{after_description}
\BLOCK{ endif -} \#{ after_description }

\BLOCK{- endif -} \#{ show_question }

\BLOCK{- if show_answer}

\BLOCK{ if simplex_pre_description -}
\VAR{simplex_pre_description}
\BLOCK{ endif } \#{ simplex_pre_description }

\BLOCK{ if lp }
<strong>解:</strong> \BLOCK{ if lp.solutionCommon.existing_basic_variable_str_list }
现有变量$\VAR{lp.solutionCommon.existing_basic_variable_str_list|join(", ")}$
可直接作为基变量使用，\BLOCK{ endif -}
\BLOCK{ if lp.solutionCommon.slack_str_list_intro or lp.solutionCommon.neg_slack_str_list_intro }引入\BLOCK{ endif -}
\BLOCK{- if lp.solutionCommon.slack_str_list_intro }松弛变量$\VAR{lp.solutionCommon.slack_str_list_intro|join(",\,") }$\BLOCK{ endif -}
\BLOCK{- if lp.solutionCommon.slack_str_list_intro and lp.solutionCommon.neg_slack_str_list_intro}，\BLOCK{ endif -}
\BLOCK{- if lp.solutionCommon.neg_slack_str_list_intro }剩余变量$\VAR{lp.solutionCommon.neg_slack_str_list_intro|join(",\,") }$\BLOCK{ endif -}
\BLOCK{ if lp.solutionCommon.slack_str_list_intro or lp.solutionCommon.neg_slack_str_list_intro }，将问题标准化. \BLOCK{ endif }
\BLOCK{if lp.solutionPhase2.method=="dual_simplex" }由于对偶可行，本问题可以用对偶单纯形法求解，将其转化为适当的形式：\BLOCK{ endif }
\BLOCK{ endif }

{% from "latex.jinja" import mytabular_preamble as preamble %}

\BLOCK{ if lp.need_artificial_variable }
<strong>大M法</strong>：引入人工变量$\VAR{lp.solutionCommon.artificial_str_list_intro|join(",\,") }$，构造人工问题：
\BLOCK{ endif }

\BLOCK{ if standardized_lp }
$$\begin{alignat*}{20}
\VAR{standardized_lp.get_goal_str()}\\
\text{s.t.}\quad
\BLOCK{ for c in standardized_lp.constraints_str_list }
\VAR{c}
\BLOCK{ endfor }
\VAR{standardized_lp.sign_str}
\end{alignat*}$$
\BLOCK{ endif }
用单纯形法求解：

<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\setcounter{keytable}{\VAR{iters.next()}}
\begin{keytable}[H]\centering
\topcaption{}
\begin{tabular}{c|c|\BLOCK{ for x in range(0, lp.solutionPhase2.all_variable_str_list|length) }
\BLOCK{ if lp.need_artificial_variable }C{1.5cm}\BLOCK{ else }C{1cm}\BLOCK{ endif }
\BLOCK{ endfor }|c}\hline\hline
\multicolumn{2}{c|}{$c_j$}\BLOCK{ for c in lp.solutionPhase2.goal_str_list }&\VAR{c}\BLOCK{ endfor }&\multirow{2}*{$\mathbf{b}$} \\ \cline{1-\VAR{lp.solutionPhase2.all_variable_str_list|length + 2 }}
$\mathbf{C_B}$&$\mathbf{X_B}$\BLOCK{ for x in lp.solutionPhase2.all_variable_str_list }&\VAR{x}\BLOCK{ endfor }&\\ \hline
\BLOCK{ for i in range(0, lp.solutionPhase2.tableau_str_list|length) }
\BLOCK{ for j in range(0, lp.solutionPhase2.cb_str_list[i]|length + 1) }
\BLOCK{ if not loop.last } \VAR{lp.solutionPhase2.cb_str_list[i][j]}&\VAR{lp.solutionPhase2.xb_str_list[i][j]}&\BLOCK{ else } \multicolumn{2}{c|}{$\bar c_j$}& \BLOCK{ endif } \VAR{lp.solutionPhase2.tableau_str_list[i][j]|join("&") } \\
\BLOCK{- if loop.revindex0 <= 1 } \hline \BLOCK{ endif }

\BLOCK{ endfor }
\BLOCK{ endfor }
\hline\end{tabular}
\end{keytable}%
{% endcall %}
</p>

\BLOCK{ if lp.solve_status_reason -}\VAR{lp.solve_status_reason}，\BLOCK{ endif -}
\BLOCK{ if lp.need_artificial_variable }
原始问题\VAR{lp.solve_status_message}
\BLOCK{ else }
该问题\VAR{lp.solve_status_message}
\BLOCK{ endif }
\BLOCK{- if lp.solve_opt_res_str -}，\VAR{lp.solve_opt_res_str}\BLOCK{ endif -}.


\BLOCK{ if show_2_stage and lp.need_artificial_variable }

<hr>

\BLOCK{ if lp2phase.solutionCommon.artificial_str_list_intro }<strong>两阶段法</strong>：引入人工变量$\VAR{lp2phase.solutionCommon.artificial_str_list_intro|join(",\,") }$，构造辅助问题：\BLOCK{ endif -}

\BLOCK{ if standardized_lp_2_phase }
$$\begin{alignat*}{20}
\VAR{standardized_lp_2_phase.get_goal_str()}\\
\text{s.t.}\quad
\BLOCK{ for c in standardized_lp_2_phase.constraints_str_list }
\VAR{c}
\BLOCK{ endfor }
\VAR{standardized_lp_2_phase.sign_str}
\end{alignat*}$$
\BLOCK{ endif }

\BLOCK{ if not lp2phase.solutionCommon.need_two_phase }用\BLOCK{if lp2phase.solutionPhase2.method=="dual_simplex" }对偶\BLOCK{ endif }单纯形法求解：\BLOCK{ else }第一阶段，求解辅助问题：\BLOCK{ endif -}


\BLOCK{ if show_2_stage and lp2phase.solutionCommon.artificial_str_list_intro }
<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\setcounter{keytable}{\VAR{iters.next()}}
\BLOCK{ if lp2phase.solutionPhase1.need_two_phase }
\begin{keytable}[H]\centering
\topcaption{\BLOCK{ if lp2phase.solutionCommon.need_two_phase }第一阶段\BLOCK{ endif }}
\begin{tabular}{c|c|\BLOCK{ for x in range(0, lp2phase.solutionPhase1.all_variable_str_list|length) }C{1cm}\BLOCK{ endfor }|c}\hline\hline
\multicolumn{2}{c|}{$c_j$}\BLOCK{ for c in lp2phase.solutionPhase1.goal_str_list }&\VAR{c}\BLOCK{ endfor }&\multirow{2}*{$\mathbf{b}$} \\ \cline{1-\VAR{lp2phase.solutionPhase1.all_variable_str_list|length + 2 }}
$\mathbf{C_B}$&$\mathbf{X_B}$\BLOCK{ for x in lp2phase.solutionPhase1.all_variable_str_list }&\VAR{x}\BLOCK{ endfor }&\\ \hline
\BLOCK{ for i in range(0, lp2phase.solutionPhase1.tableau_str_list|length) }
\BLOCK{ for j in range(0, lp2phase.solutionPhase1.cb_str_list[i]|length + 1) }
\BLOCK{ if not loop.last } \VAR{lp2phase.solutionPhase1.cb_str_list[i][j]}&\VAR{lp2phase.solutionPhase1.xb_str_list[i][j]}&\BLOCK{ else } \multicolumn{2}{c|}{$\bar c_j$}& \BLOCK{ endif } \VAR{lp2phase.solutionPhase1.tableau_str_list[i][j]|join("&") } \\
\BLOCK{- if loop.revindex0 <= 1 } \hline \BLOCK{ endif }

\BLOCK{ endfor }
\BLOCK{ endfor }
\hline\end{tabular}
\end{keytable}%
\BLOCK{ endif }


\BLOCK{ if pre_stage_2_description -}
\VAR{pre_stage_2_description}
\BLOCK{ endif }
{% endcall %}
</p>
\BLOCK{ endif }

\BLOCK{ if lp2phase.has_phase_2 }
\BLOCK{ if show_2_stage and lp2phase.solutionCommon.artificial_str_list_intro }
由于第一阶段目标函数值为0，进入第二阶段求解：
\BLOCK{ endif }

<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\setcounter{keytable}{\VAR{iters.next()}}
\begin{keytable}[H]\centering
\topcaption{\BLOCK{ if lp2phase.solutionPhase1.need_two_phase }第二阶段\BLOCK{ endif }}
\begin{tabular}{c|c|\BLOCK{ for x in range(0, lp2phase.solutionPhase2.all_variable_str_list|length) }C\BLOCK{ if lp2phase.solutionPhase2.method=="big_m_simplex" }{1.2cm}\BLOCK{ else }{1cm}\BLOCK{ endif }\BLOCK{ endfor }|c}\hline\hline
\multicolumn{2}{c|}{$c_j$}\BLOCK{ for c in lp2phase.solutionPhase2.goal_str_list }&\VAR{c}\BLOCK{ endfor }&\multirow{2}*{$\mathbf{b}$} \\ \cline{1-\VAR{lp2phase.solutionPhase2.all_variable_str_list|length + 2 }}
$\mathbf{C_B}$&$\mathbf{X_B}$\BLOCK{ for x in lp2phase.solutionPhase2.all_variable_str_list }&\VAR{x}\BLOCK{ endfor }&\\ \hline
\BLOCK{ for i in range(0, lp2phase.solutionPhase2.tableau_str_list|length) }
\BLOCK{ for j in range(0, lp2phase.solutionPhase2.cb_str_list[i]|length + 1) }
\BLOCK{ if not loop.last } \VAR{lp2phase.solutionPhase2.cb_str_list[i][j]}&\VAR{lp2phase.solutionPhase2.xb_str_list[i][j]}&\BLOCK{ else } \multicolumn{2}{c|}{$\bar c_j$}& \BLOCK{ endif } \VAR{lp2phase.solutionPhase2.tableau_str_list[i][j]|join("&") } \\
\BLOCK{- if loop.revindex0 <= 1 } \hline \BLOCK{ endif }

\BLOCK{ endfor }
\BLOCK{ endfor }
\hline\end{tabular}
\end{keytable}%
{% endcall %}
</p>

\BLOCK{ endif }

\BLOCK{ if lp2phase.solve_status_reason -}\VAR{lp2phase.solve_status_reason}，\BLOCK{ endif -}
该问题\VAR{lp2phase.solve_status_message}
\BLOCK{- if lp2phase.solve_opt_res_str -}，\VAR{lp2phase.solve_opt_res_str}\BLOCK{ endif -}.

\BLOCK{ endif } \#{ if show_2_stage }

\BLOCK{ if lp.solutionCommon.method == "modified_simplex" }
%# 改进单纯形法开始
\BLOCK{ for idx in range(lp.solutionPhase2.modi_basis_list|length) }
<strong>(\VAR{loop.index}).</strong> 基变量向量为$\mathbf{X_B}=(\VAR{lp.solutionPhase2.modi_basis_list[idx]|join(", ")})^T$，有：
$$\mathbf{B}=(\VAR{lp.solutionPhase2.modi_bp_list[idx]|join(", ")})=\begin{bmatrix}
\VAR{lp.solutionPhase2.modi_B_list[idx]|join("")}
\end{bmatrix}\quad \Rightarrow \quad \mathbf{B}^{-1}=\begin{bmatrix}
\VAR{lp.solutionPhase2.modi_B_1_list[idx]|join("")}
\end{bmatrix}$$

计算非基变量的检验数$\bar c_j$：
$$\begin{align*}
\BLOCK{ for cjbar_idx in lp.solutionPhase2.modi_CJBAR_idx_list[idx] }
\bar c_{\VAR{cjbar_idx+1}}&=c_{\VAR{cjbar_idx+1}}-\mathbf{C_B}\mathbf{B}^{-1}\mathbf{p}_{\VAR{cjbar_idx+1}}=\VAR{lp.solutionPhase2.modi_CJBAR_list[idx][cjbar_idx]} \\
\BLOCK{ endfor }
\end{align*}$$

\BLOCK{ if not loop.last }
$x_{\VAR{lp.solutionPhase2.pivot_list[idx][1]+1}}$为入基变量。计算$\bar p_{\VAR{lp.solutionPhase2.pivot_list[idx][0]+1}}$和$\bar b$以确定出基变量：
\BLOCK{ endif }
\BLOCK{ if not loop.last }$$\mathbf{\bar p}_{\VAR{lp.solutionPhase2.pivot_list[idx][0]+1}}=\mathbf{B}^{-1}{\mathbf{p}_{\VAR{lp.solutionPhase2.pivot_list[idx][0]+1}}}=\begin{bmatrix}
\VAR{lp.solutionPhase2.modi_pj_list[idx]|join(" \\\\ ")}
\end{bmatrix},
\quad
\mathbf{\bar b}=\mathbf{B}^{-1}\mathbf{b}=\begin{bmatrix} \VAR{lp.solutionPhase2.modi_b_list[idx]|join(" \\\\ ")} \end{bmatrix}$$

应用最小比值准则选择$x_{\VAR{lp.solutionPhase2.basis_list[idx][lp.solutionPhase2.pivot_list[idx][0]]+1}}$为出基变量，从而得到新的基变量向量；
\BLOCK{ else }

\BLOCK{ if lp.solve_status==2 }
$$\mathbf{X^*_B}= \mathbf{\bar b}=\mathbf{B}^{-1}\mathbf{b}=\begin{bmatrix} \VAR{lp.solutionPhase2.modi_b_list[idx]|join(" \\\\ ")} \end{bmatrix}$$
\BLOCK{ endif }
\BLOCK{ if lp.solve_status_reason -}\VAR{lp.solve_status_reason}，\BLOCK{ endif -}
\BLOCK{ if lp.need_artificial_variable }
原始问题\VAR{lp.solve_status_message}
\BLOCK{ else }
该问题\VAR{lp.solve_status_message}
\BLOCK{ endif }
\BLOCK{ if lp.solve_status<1 }
$$\mathbf{X^*_B}= \mathbf{\bar b}=\mathbf{B}^{-1}\mathbf{b}=\begin{bmatrix} \VAR{lp.solutionPhase2.modi_b_list[idx]|join(" \\\\ ")} \end{bmatrix}$$
\BLOCK{ endif -}
\BLOCK{- if lp.solve_opt_res_str -}\VAR{lp.solve_opt_res_str}\BLOCK{ endif -}.

\BLOCK{ endif -}

\BLOCK{ endfor -}

%# 改进单纯形法结束
\BLOCK{ endif -}


\BLOCK{- if simplex_after_description -}
\VAR{simplex_after_description}
\BLOCK{ endif -}

\BLOCK{ endif -} \#{ show_answer }