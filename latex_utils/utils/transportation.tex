\BLOCK{ set qtable=t.question_table_element }
\BLOCK{- if t.is_sup_bounded_problem }\BLOCK{ set dim_name= qtable.sup_desc}\BLOCK{ set max_name= qtable.sup_max_desc}\BLOCK{ set total_name= qtable.dem_amount_desc}\BLOCK{ endif -}
\BLOCK{- if t.is_dem_bounded_problem }\BLOCK{ set dim_name= qtable.dem_desc}\BLOCK{ set max_name= qtable.dem_max_desc}\BLOCK{ set total_name= qtable.sup_amount_desc}\BLOCK{ endif -}

\BLOCK{- if show_question -}

\BLOCK{ if problem_description_pre -}
\VAR{description}
\BLOCK{ endif }

\BLOCK{if standardize_only }将以下问题转化为标准(产销平衡)的运输问题
\BLOCK{- if t.is_sup_bounded_problem }，使得在最低供应量必须运出的前提下，尽可能多地满足各地的需求\BLOCK{ endif -}
\BLOCK{- if t.is_dem_bounded_problem }，使得在最低需求量必须满足的前提下，尽可能多地满足各地的需求\BLOCK{ endif -}.
\BLOCK{else}
求解以下运输问题的最优运输方案，
\BLOCK{- if t.is_sup_bounded_problem }使得在最低供应量必须运出的前提下，尽可能多地满足各地的需求\BLOCK{ endif -}
\BLOCK{- if t.is_dem_bounded_problem }使得在最低需求量必须满足的前提下，尽可能多地满足各地的需求\BLOCK{ endif -}
\BLOCK{if init_method}，要求初始基本可行方案用<strong>\VAR{init_method}<\strong>得出\BLOCK{endif}.
\BLOCK{endif}

{% from "latex.jinja" import transportation_preamble as preamble %}

<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\BLOCK{ if t.question_table_element and t.costs_str -}
\BLOCK{ set qtable=t.question_table_element } \BLOCK{ set costs=t.costs_str }
\setcounter{table}{\VAR{question_iters.next()}}
\begin{\VAR{qtable.tex_table_type}}[H]\centering \topcaption{}
\begin{mytabular}{c|\BLOCK{ for x in range(0, t.n_dem) }c\BLOCK{ endfor }|c\BLOCK{if t.is_sup_bounded_problem}|c\BLOCK{endif}}\hline\hline \diagbox{\VAR{qtable.sup_desc}}{\VAR{qtable.cost_desc}}{\VAR{qtable.dem_desc}}
&\VAR{qtable.dem_name_list|join("&")}&\BLOCK{if t.is_sup_bounded_problem}\VAR{qtable.sup_min_desc}&\VAR{qtable.sup_max_desc}\BLOCK{else}\VAR{qtable.sup_amount_desc}\BLOCK{endif}\\ \hline
\BLOCK{ for idx in range(0, t.n_sup) } \VAR{ qtable.sup_name_list[idx] } & \VAR{costs[idx]|join("&")} & \BLOCK{if t.is_sup_bounded_problem}\VAR{t.sup_lower_bound_list_str[idx]}&\VAR{t.sup_upper_bound_list_str[idx]}\BLOCK{else}\VAR{t.sup[idx]}\BLOCK{endif} \\
\BLOCK{ endfor } \hline
\BLOCK{if t.is_dem_bounded_problem}
\VAR{qtable.dem_min_desc}&\VAR{t.dem_lower_bound_list_str|join("&")}&\\ \hline
\VAR{qtable.dem_max_desc}&\VAR{t.dem_upper_bound_list_str|join("&")}&\\
\BLOCK{else}
\VAR{qtable.dem_amount_desc}&\VAR{t.dem|join("&")}&\\
\BLOCK{endif}
\hline\hline
\end{mytabular}\end{\VAR{qtable.tex_table_type}}

\BLOCK{ endif} \#{t.question_table_element and t.costs_str}

{% endcall %}</p>


\BLOCK{ endif } \#{ show_question }

\BLOCK{ if show_answer}
<strong>解：</strong>本问题为\BLOCK{- if t.is_standard_problem -}产销平衡运输问题
\BLOCK{- elif t.is_sup_bounded_problem -}最低产量必须运出的运输问题
\BLOCK{- elif t.is_dem_bounded_problem -}最低需求必须满足的运输问题
\BLOCK{- else -}产销不平衡问题
\BLOCK{- endif-}.

\BLOCK{ if t.is_sup_bounded_problem or t.is_dem_bounded_problem }
\BLOCK{ if t.is_sup_bounded_problem }\BLOCK{ set dim_name= qtable.sup_desc}\BLOCK{ set max_name= qtable.sup_max_desc}\BLOCK{ set total_name= qtable.dem_amount_desc}\BLOCK{ endif }
\BLOCK{ if t.is_dem_bounded_problem }\BLOCK{ set dim_name= qtable.dem_desc}\BLOCK{ set max_name= qtable.dem_max_desc}\BLOCK{ set total_name= qtable.sup_amount_desc}\BLOCK{ endif }

\BLOCK{ if t.is_infinity_bounded_problem}由于只有一个\VAR{dim_name}的\VAR{max_name}为“无上限”，可计算出其理论上限：
该\VAR{dim_name}的\VAR{max_name}为\VAR{t.infty_theoretical_value}. \BLOCK{endif}

\BLOCK{ if t.question_no_need_consider_bound }计算可知，总\VAR{total_name}可以满足所有\VAR{dim_name}的\VAR{max_name}，无须进行分割操作.\BLOCK{endif}

\BLOCK{ endif } \#{t.is_sup_bounded_problem }

\BLOCK{ if not t.is_standard_problem }
标准化后的运输问题的运价表为：

<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\BLOCK{ if t.standard_table_element and t.standard_costs_str -}
\BLOCK{ set qtable=t.standard_table_element } \BLOCK{ set costs=t.standard_costs_str }
\setcounter{keytable}{\VAR{iters.next()}}
\begin{\VAR{qtable.tex_table_type}}[H]\centering \topcaption{}
\begin{mytabular}{c|\BLOCK{ for x in range(qtable.dem_name_list|length) }c\BLOCK{ endfor }|c}\hline\hline \diagbox{\VAR{qtable.sup_desc}}{\VAR{qtable.cost_desc}}{\VAR{qtable.dem_desc}}
&\VAR{qtable.dem_name_list|join("&")}&\VAR{qtable.sup_amount_desc}\\ \hline
\BLOCK{ for idx in range(qtable.sup_name_list|length) } \VAR{ qtable.sup_name_list[idx] } & \VAR{costs[idx]|join("&")} & \VAR{t.standard_sup[idx]} \\
\BLOCK{ endfor } \hline
\VAR{qtable.dem_amount_desc}&\VAR{t.standard_dem|join("&")}&\VAR{t.standard_total_amount}\\
\hline\hline
\end{mytabular}\end{\VAR{qtable.tex_table_type}}

\BLOCK{ endif} \#{t.question_table_element and t.costs_str}

{% endcall %}</p>

\BLOCK{ endif}  \#{not t.is_standard_problem }

\BLOCK{ if not standardize_only }

\BLOCK{ for method_idx in range(used_method_list|length)}
\BLOCK{ if not loop.first}<hr>\BLOCK{endif}

用\VAR{used_method_list[method_idx]}得到的初始基本可行方案及后续求解如下：

<p align="middle">
{% call latex(compiler="pdflatex", image_format="png", tex_preamble=preamble)  %}
\BLOCK{ set qtable=t.solve_table_element } \BLOCK{ set costs=t.standard_costs_str_tikz }
\def\ori{  {  \BLOCK{for idx in (range(costs|length))|reverse}{\VAR{costs[idx]|join(",")}},\BLOCK{endfor}  }  }
\def\sremainder{
\BLOCK{for idx in (range(t.standard_sup|length))|reverse}
\draw (sr\VAR{loop.index0}) node{\footnotesize \VAR{t.standard_sup[idx]}};
\BLOCK{ endfor }
}
\def\dremainder{
\BLOCK{for idx in (range(t.standard_dem|length))|reverse}
\draw (dr\VAR{loop.index0}) node{\footnotesize \VAR{t.standard_dem[idx]}};
\BLOCK{ endfor }
}
\def\total{\footnotesize \VAR{t.standard_total_amount}}

\BLOCK{ set solution_list=method_result_list[method_idx].solution_list}
\BLOCK{ set verify_list=method_result_list[method_idx].s_matrix_list}
\BLOCK{ set vogel_list=method_result_list[method_idx].vogel_list}
\BLOCK{ set n_iter=solution_list|length}


\BLOCK{ for it in range(n_iter) -}
\BLOCK{ set result=solution_list[it]}
\BLOCK{ set verify=verify_list[it]}
\noindent\begin{minipage}[c]{0.5\textwidth}
\parindent 2em

\setcounter{keytable}{\VAR{iters.next()}}
\begin{keytable}[H]
\centering
\topcaption{}
\def\flows{  {  \BLOCK{for idx in (range(result|length))|reverse}{\VAR{result[idx]|join(",")}},\BLOCK{endfor}  }  }
\begin{tikzpicture}[>=stealth]\draw[thick, draw=black] (0,0) grid (\VAR{t.standard_n_dem},\VAR{t.standard_n_sup});%%%无运输图
\draworiginlabelwithoutnodelabel{\ori}{\VAR{t.standard_n_sup-1}}{\VAR{t.standard_n_dem-1}}
\drawflow{\flows}{\VAR{t.standard_n_sup-1}}{\VAR{t.standard_n_dem-1}}
\sremainder
\dremainder
\BLOCK{- for x in range(0, t.standard_n_dem) }
\node at (B\VAR{x}) {\VAR{qtable.dem_name_list[x]}};
\BLOCK{ endfor -}
\BLOCK{- for x in range(0, t.standard_n_sup) }
\node at (A\VAR{t.standard_n_sup-x-1}) {\VAR{qtable.sup_name_list[x]}};
\BLOCK{ endfor -}
\end{tikzpicture}
\end{keytable}

\end{minipage}%
\hskip 2em
\BLOCK{ if verify }
\noindent\begin{minipage}[c]{0.5\textwidth}
\parindent 2em
检验数表为：

\setcounter{keytable}{\VAR{iters.next()}}
\begin{keytable}[H]
\centering \topcaption{检验数表}%\label{tab:jysb1}
\begin{mytabular}{c|\BLOCK{ for x in range(0, t.standard_n_dem) }|C{2.5em}\BLOCK{ endfor }  }
\hline\hline
& \VAR{qtable.dem_name_list|join("&")} \\ \hline\hline
\BLOCK{ for x in range(0, t.standard_n_sup) }
\VAR{qtable.dem_name_list[x]} & \VAR{verify[x]|join("&")}\\ \hline
\BLOCK{ endfor }
\hline
\end{mytabular}
\end{keytable}

\end{minipage}

\BLOCK{ endif }

\BLOCK{ if not loop.last }

\vskip 1em

\BLOCK{ endif }

\BLOCK{ endfor }

{% endcall %}</p>
\BLOCK{ endfor }\#{ method in used_method_list}
\BLOCK{ endif } \#{not standardize_only }


\BLOCK{- endif } \#{ show_answer }

